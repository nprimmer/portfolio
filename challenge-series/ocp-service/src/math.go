package main

import (
	"fmt"
	"math/rand"
	"strconv"
	"strings"
	"unicode"

	log "github.com/sirupsen/logrus"
)

var maxNumber = 999

func generateEquation(value int) equation {
	if value <= 1 {
		value = 1
	}
	log.Infof("Generating new equation of value %d", value)
	a := getRandomNumber(maxNumber)
	question := strconv.Itoa(a)
	for i := 1; i <= value; i++ {
		operation := randomOperation()
		b := getRandomNumber(maxNumber)
		question = question + fmt.Sprintf(" %s %s", operation, strconv.Itoa(b))
		a = b
	}
	answer := solveEquation(question)
	presentedAnswer := presentedFor(answer, value)
	response := equation{
		Question:        question,
		RealAnswer:      answer,
		Value:           value,
		PresentedAnswer: presentedAnswer,
	}
	log.Infof("Generated Question: %s, Real Answer: %d, Presented Answer: %d", response.Question, response.RealAnswer, response.PresentedAnswer)
	return response
}

// No divisions to avoid floats, precision, etc.
var operations = []string{"+", "-", "*"}

func presentedFor(answer int, likelihood int) int {
	if getRandomNumber(100) <= likelihood {
		log.Infof("Equation generated with correct answer.")
		return answer
	}
	log.Infof("Equation generated with incorrect answer.")
	newEquation := fmt.Sprintf("%s %s %s", strconv.Itoa(answer), randomOperation(), strconv.Itoa(getRandomNumber(10)))
	answer = solveEquation(newEquation)
	return answer
}

func getRandomNumber(max int) int {
	return rand.Intn(max)
}

func randomOperation() string {
	return operations[rand.Intn(len(operations))]
}

// The remainder of the funcs in this file were modified from code generated by ChatGPT, and are basically the solution as well.
func solveEquation(equation string) int {
	log.Infof("Solving equation %s", equation)
	postfix := toPostfix(equation)
	return evaluatePostfix(postfix)
}

func evaluatePostfix(postfix string) int {
	var stack []int
	log.Infof("evaluate postfix: %s", postfix)
	for _, token := range strings.Fields(postfix) {
		log.Infof("Postfix field: %s", token)
		switch token {
		case "+", "-", "*":
			y, x := stack[len(stack)-1], stack[len(stack)-2]
			stack = stack[:len(stack)-2]
			switch token {
			case "+":
				stack = append(stack, x+y)
			case "-":
				stack = append(stack, x-y)
			case "*":
				stack = append(stack, x*y)
			}
		default:
			num, _ := strconv.Atoi(token)
			stack = append(stack, num)
		}
	}

	return stack[0]
}

type stack []string

func (s *stack) push(str string) {
	*s = append(*s, str)
}

func (s *stack) pop() string {
	if len(*s) == 0 {
		return ""
	}
	element := (*s)[len(*s)-1]
	*s = (*s)[:len(*s)-1]
	return element
}

func (s *stack) peek() string {
	if len(*s) == 0 {
		return ""
	}
	return (*s)[len(*s)-1]
}

func (s *stack) empty() bool {
	return len(*s) == 0
}

func precedence(op string) int {
	switch op {
	case "+", "-":
		return 1
	case "*", "/":
		return 2
	default:
		return 0
	}
}

func toPostfix(infix string) string {
	var output stack
	var ops stack

	// Improved tokenization
	var tokens []string
	for i := 0; i < len(infix); i++ {
		char := infix[i]
		if unicode.IsDigit(rune(char)) {
			start := i
			for i < len(infix) && (unicode.IsDigit(rune(infix[i])) || infix[i] == '.') {
				i++
			}
			tokens = append(tokens, infix[start:i])
			i-- // adjust because the for loop will increment i
		} else if strings.ContainsRune("+-*/()", rune(char)) {
			if char == '-' && (i == 0 || infix[i-1] == '(') {
				// Unary minus handling
				tokens = append(tokens, "0")
			}
			tokens = append(tokens, string(char))
		}
	}

	for _, token := range tokens {
		switch {
		case token == "(":
			ops.push(token)
		case token == ")":
			for !ops.empty() && ops.peek() != "(" {
				output.push(ops.pop())
			}
			ops.pop()
		case strings.Contains("+-*/", token):
			for !ops.empty() && precedence(ops.peek()) >= precedence(token) {
				output.push(ops.pop())
			}
			ops.push(token)
		default:
			output.push(token)
		}
	}

	for !ops.empty() {
		output.push(ops.pop())
	}

	return strings.Join(output, " ")
}
